&emsp;&emsp; Kotlin引入的新概念：实化类型参数和声明点变型。  
&emsp;&emsp; 实化类型参数允许你在运行时的内联函数调用中引用作为类型实参的具体类型。  
&emsp;&emsp; 声明点变量可以说明一个带类型参数的泛型类型，是否是另一个泛型类型的字类型或者超类型。  
## 9.1 泛型类型参数
&emsp;&emsp; 泛型允许你定义带类型形参的类型。当这种类型的实例被创建出来的时候，类型形参被替换成称为类型实参的具体类型。
#### &emsp; 9.1.1 泛型函数和属性
&emsp;&emsp; 普通（即非扩展）属性不能拥有类型参数，不能在一个类的属性中存储多个不同类型的值，因此声明泛型非扩展函数没有意义。
#### &emsp; 9.1.2 声明泛型类
&emsp;&emsp; Kotlin的声明和java的一样
#### &emsp; 9.1.3 类型参数约束
&emsp;&emsp; 类型参数约束可以限制作为（泛型）类和（泛型）函数的类型实参的类型。
#### &emsp; 9.1.4 让类型形参非空
&emsp;&emsp; 没有指定上界的类型形参将会使用Any？这个默认的上界。  
&emsp;&emsp; 约束<T:Any>确保了类型T永远都是非空类型。
## 9.2 运行时的泛型：擦除和实化类型参数
&emsp;&emsp; JVM上的泛型一般是通过类型擦除实现的。可以声明一个inline函数，让其类型实参不被擦除（kotlin术语，称作实化）。
#### &emsp; 9.2.1 运行时的泛型：类型检查和转换
&emsp;&emsp; 擦除类型信息的约束：因为类型实参没有被存储下来，你不能检查它们。  
&emsp;&emsp; 检查一个值是否是列表：使用特殊的星号投影语法来做检查  
&emsp;&emsp; if(value is List<*>){...}
#### &emsp; 9.2.2 声明带实化类型参数的函数
&emsp;&emsp; 内联函数的类型形参能够被实化。  
&emsp;&emsp; 编译器把实现内联函数的字节码器插入到每一个调用发生的地方。每次你调用带实例化类型形参的函数时，编译器都知道这次特定调用中作类型实参的确切类型。  
&emsp;&emsp; 带reified类型参数的inline函数不能在java代码中调用，普通的内联函数可以像常规函数那样在java中调用————它们可以被调用而不能被内联。
#### &emsp; 9.2.3 使用实化类型参数代替类引用
&emsp;&emsp; ::class.java 的语法展现了如何获取java.lang.Class对应的kotlin类，这和java中的.class是完全等同的。
#### &emsp; 9.2.4 实化类型参数的限制
## 9.3 变型：泛型和子类型化
&emsp;&emsp; 变型：拥有相同基础类型和不同类型实参的（泛型）类型之间是如何关联的。
#### &emsp; 9.3.1 为什么存在变型：给函数传递实参
&emsp;&emsp; 把一个字符串列表传递给期望Any对象列表的函数是否安全？如果函数添加或者替换了列表中的元素就是不安全的，因为这样会产生类型不一致的可能性。
#### &emsp; 9.3.2 类、类型和子类型
&emsp;&emsp; 子类型和超类型的区别
#### &emsp; 9.3.3 协变：保留子类型化关系
&emsp;&emsp; 如果A是B的子类型，那么List&lt; A&gt;就是List&lt; B&gt;的子类型，这样的类或者接口被称为协变的。    
&emsp;&emsp; 在kotlin中，要声明类在某个类型参数上上可以协变的，在该类型参数的名称前面加上out关键字即可。  
&emsp;&emsp; 在类成员的声明中，类型参数的使用可以分为in位置和out位置。  
&emsp;&emsp; 函数参数的类型叫作in位置，而函数返回类型叫作out位置。  
&emsp;&emsp; 类型参数T 上的关键字out有两层含义：子类型化会被保留。T只能在out位置。  
&emsp;&emsp; 构造方法的参数既不在in位置也不在out位置。
#### &emsp; 9.3.4 逆变：反转子类型化关系
&emsp;&emsp; 逆变的概念可以被看成是协变的镜像。  
&emsp;&emsp; 对协变类型来说，子类型化保留了，但逆变类型、子类型化反转了。
#### &emsp; 9.3.5 使用点变型：在类型出现的地方指定变型
&emsp;&emsp; 在类声明的时候就能够指定变型修饰符是很方便的，因为这些修饰符会应用到所有类被使用的地方。这被称作声明点变型。  
&emsp;&emsp; 编译器禁止调用使用类型参数做实参（类型）的那些方法（在in位置使用类型参数）。  
&emsp;&emsp; Kotlin中的MutableList &lt; out T&gt;和java中的MutableList &lt; ? extends T &gt; 是一个意思。in投影的mutableList &lt; in T &gt;对应到java的MutableList &lt; ? supper T &gt;
#### &emsp; 9.3.6 星号投影：使用*代替类型参数
&emsp;&emsp; 一种特殊的星号投影语法，可以用它来表明你不知道关于泛型实参的任何消息。   
&emsp;&emsp; MutableList &lt; * &gt; 投影成了MutableList &lt; out Any? &gt;:当你没有任何元素类型信息的时候，读取Any？类型的元素仍然是安全的，但是向列表中写入元素是不安全的。  
&emsp;&emsp; 对像Consume &lt; in T &gt;这样的逆变类型参数来说，星号投影等价于 &lt; in Noting &gt;。  
&emsp;&emsp; 星号投影的语法：只能用在对泛型类型实参的确切值不感兴趣的地方：只要是使用生产值的方法，而且不关心那些值得类型。 