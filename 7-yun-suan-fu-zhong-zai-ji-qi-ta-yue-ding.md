## 7.1 重载算数运算符
#### &emsp; 7.1.1 重载二元算术运算
&emsp;&emsp; 用于操作符重载的所有函数使用operator关键字标记
#### &emsp; 7.1.2 重载复合赋值运算符
&emsp;&emsp;像+=、-=等这些运算符被称为复合赋值运算符。
#### &emsp; 7.1.3 重载一元运算符
## 7.2 重载比较运算符
#### &emsp; 7.2.1 等号运算符"equal"
&emsp;&emsp;继承自Any类的实现始终优先于扩展函数。  
&emsp;&emsp;恒等运算符与java中的==运算符是完全相等的。
#### &emsp; 7.2.2 排序运算符：compareTo
## 7.3 集合与区间的约定
#### &emsp; 7.3.1 通过下标来访问元素"get"和"set"
&emsp;&emsp;下标运算符 a[b]
#### &emsp; 7.3.2 "in"的约定
&emsp;&emsp;用in运算符来检查某个对象是否属于集合。  
&emsp;&emsp;10..20构建一个区间（闭区间），该区间包括10到20的所有数字，包括20.  
&emsp;&emsp;开区间10 until 20，包括从10到19的数字，但不包括20.
#### &emsp; 7.3.3 rangeTo的约定
&emsp;&emsp;rangeTo 运算符的优先级低于算术运算符。
#### &emsp; 7.3.4 在"for"循环中使用“iterator”的约定
## 7.4 解构声明和组件函数
&emsp;&emsp;解构声明主要使用场景之一，是从一个函数返回多个值，如果要这样做，可以定义一个数据类保存返回所需的值，并将它作为函数的返回类型。  
&emsp;&emsp;标准库只允许使用此语法来访问一个对象的前五个元素。若要返回更多值，使用标准库中的Pair和Triple类。示例如下：  
&emsp;&emsp;val p = Point (10,20)  
&emsp;&emsp;val (x,y) =   p  
&emsp;&emsp;printIn(x) 结果为10  
&emsp;&emsp;printIn(y)结果为20
#### &emsp; 7.4.1 解构声明和循环
## 7.5 重用属性访问的逻辑：委托属性
&emsp;&emsp;kotlin中最独特和最强大的功能之一：委托属性。  
&emsp;&emsp;这个功能的基础是委托，这是一种设计模式，标准的对象不用自己执行，而是把工作委托给另一个辅助的对象，我们把扶助对象称为委托。
#### &emsp; 7.5.1 委托属性的基本操作
&emsp;&emsp;by可以用于任何符合属性委托约定规则的对象。  
&emsp;&emsp;委托类必须具有getValue和setValue方法。
#### &emsp; 7.5.2 使用委托属性：惰性初始化和"by lazy()"
&emsp;&emsp;惰性初始化是一种常见的模式，直到在第一次访问该属性的时候，才根据需要创建对象的一部分，当初始化过程消耗大量资源并且在使用对象时并不总是需要数据。  
&emsp;&emsp;lazy函数是线程安全的。
#### &emsp; 7.5.3 实现委托属性
#### &emsp; 7.5.4 委托属性的变换规则
#### &emsp; 7.5.5 在map中保存属性值
&emsp;&emsp;委托属性发挥作用的另一种常见用法是用在有动态主义的属性集的对象中。这样的对象有时被称为自订对象。
#### &emsp; 7.5.6 框架中的委托属性